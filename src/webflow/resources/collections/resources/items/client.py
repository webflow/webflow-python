# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from .....core.api_error import ApiError
from .....core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .....core.jsonable_encoder import jsonable_encoder
from .....core.pydantic_utilities import pydantic_v1
from .....core.request_options import RequestOptions
from .....errors.bad_request_error import BadRequestError
from .....errors.internal_server_error import InternalServerError
from .....errors.not_found_error import NotFoundError
from .....errors.too_many_requests_error import TooManyRequestsError
from .....errors.unauthorized_error import UnauthorizedError
from .....types.collection_item import CollectionItem
from .....types.collection_item_field_data import CollectionItemFieldData
from .....types.collection_item_list import CollectionItemList
from .types.bulk_collection_item_field_data import BulkCollectionItemFieldData
from .types.items_list_items_live_request_sort_by import ItemsListItemsLiveRequestSortBy
from .types.items_list_items_live_request_sort_order import ItemsListItemsLiveRequestSortOrder
from .types.items_list_items_request_sort_by import ItemsListItemsRequestSortBy
from .types.items_list_items_request_sort_order import ItemsListItemsRequestSortOrder

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ItemsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_items(
        self,
        collection_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        name: typing.Optional[str] = None,
        slug: typing.Optional[str] = None,
        sort_by: typing.Optional[ItemsListItemsRequestSortBy] = None,
        sort_order: typing.Optional[ItemsListItemsRequestSortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItemList:
        """
        List of all Items within a Collection. </br></br> Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        name : typing.Optional[str]
            The name of the item(s)

        slug : typing.Optional[str]
            The slug of the item

        sort_by : typing.Optional[ItemsListItemsRequestSortBy]
            Sort results by the provided value

        sort_order : typing.Optional[ItemsListItemsRequestSortOrder]
            Sorts the results by asc or desc

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItemList
            Request was successful

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.list_items(
            collection_id="collection_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
                "offset": offset,
                "limit": limit,
                "name": name,
                "slug": slug,
                "sortBy": sort_by,
                "sortOrder": sort_order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItemList, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_item(
        self,
        collection_id: str,
        *,
        id: str,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Create Item in a Collection.</br></br> To create items across multiple locales, <a href="https://developers.webflow.com/data/reference/create-item-for-multiple-locales"> please use this endpoint.</a> </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        id : str
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow import CollectionItemFieldData
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.create_item(
            collection_id="collection_id",
            id="42b720ef280c7a7a3be8cabe",
            cms_locale_id="653ad57de882f528b32e810e",
            last_published="2022-11-29T16:22:43.159Z",
            last_updated="2022-11-17T17:19:43.282Z",
            created_on="2022-11-17T17:11:57.148Z",
            is_archived=False,
            is_draft=False,
            field_data=CollectionItemFieldData(
                name="Pan Galactic Gargle Blaster Recipe",
                slug="pan-galactic-gargle-blaster",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="POST",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": field_data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_items_live(
        self,
        collection_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        name: typing.Optional[str] = None,
        slug: typing.Optional[str] = None,
        sort_by: typing.Optional[ItemsListItemsLiveRequestSortBy] = None,
        sort_order: typing.Optional[ItemsListItemsLiveRequestSortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItemList:
        """
        List of all live Items within a Collection. </br></br> Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        name : typing.Optional[str]
            The name of the item(s)

        slug : typing.Optional[str]
            The slug of the item

        sort_by : typing.Optional[ItemsListItemsLiveRequestSortBy]
            Sort results by the provided value

        sort_order : typing.Optional[ItemsListItemsLiveRequestSortOrder]
            Sorts the results by asc or desc

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItemList
            Request was successful

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.list_items_live(
            collection_id="collection_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
                "offset": offset,
                "limit": limit,
                "name": name,
                "slug": slug,
                "sortBy": sort_by,
                "sortOrder": sort_order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItemList, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_item_live(
        self,
        collection_id: str,
        *,
        id: str,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Create live Item in a Collection. This Item will be published to the live site. </br></br> To create items across multiple locales, <a href="https://developers.webflow.com/data/reference/create-item-for-multiple-locales"> please use this endpoint.</a> </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        id : str
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow import CollectionItemFieldData
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.create_item_live(
            collection_id="collection_id",
            id="42b720ef280c7a7a3be8cabe",
            cms_locale_id="653ad57de882f528b32e810e",
            last_published="2022-11-29T16:22:43.159Z",
            last_updated="2022-11-17T17:19:43.282Z",
            created_on="2022-11-17T17:11:57.148Z",
            is_archived=False,
            is_draft=False,
            field_data=CollectionItemFieldData(
                name="Pan Galactic Gargle Blaster Recipe",
                slug="pan-galactic-gargle-blaster",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="POST",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": field_data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_item_for_multiple_locales(
        self,
        collection_id: str,
        *,
        id: str,
        cms_locale_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[BulkCollectionItemFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Create single Item in a Collection with multiple corresponding locales. </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        id : str
            Unique identifier for the Item

        cms_locale_ids : typing.Optional[typing.Sequence[str]]
            Array of identifiers for the locales where the item will be created

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[BulkCollectionItemFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.create_item_for_multiple_locales(
            collection_id="collection_id",
            id="580e64008c9a982ac9b8b754",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/bulk",
            method="POST",
            json={
                "id": id,
                "cmsLocaleIds": cms_locale_ids,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": field_data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Get details of a selected Collection Item. </br></br> Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.get_item(
            collection_id="collection_id",
            item_id="item_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="GET",
            params={"cmsLocaleId": cms_locale_id},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItem, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete an Item from a Collection. This endpoint does not currently support bulk deletion. </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.delete_item(
            collection_id="collection_id",
            item_id="item_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="DELETE",
            params={"cmsLocaleId": cms_locale_id},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        id: str,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Update a selected Item in a Collection. </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        id : str
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow import CollectionItemFieldData
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.update_item(
            collection_id="collection_id",
            item_id="item_id",
            id="42b720ef280c7a7a3be8cabe",
            cms_locale_id="653ad57de882f528b32e810e",
            last_published="2022-11-29T16:22:43.159Z",
            last_updated="2022-11-17T17:19:43.282Z",
            created_on="2022-11-17T17:11:57.148Z",
            is_archived=False,
            is_draft=False,
            field_data=CollectionItemFieldData(
                name="Pan Galactic Gargle Blaster Recipe",
                slug="pan-galactic-gargle-blaster",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="PATCH",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": field_data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItem, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Get details of a selected Collection live Item. </br></br> Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.get_item_live(
            collection_id="collection_id",
            item_id="item_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="GET",
            params={"cmsLocaleId": cms_locale_id},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItem, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Remove a live item from the site. Removing a published item will unpublish the item from the live site and set it to draft. This endpoint does not currently support bulk deletion. </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.delete_item_live(
            collection_id="collection_id",
            item_id="item_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="DELETE",
            params={"cmsLocaleId": cms_locale_id},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        id: str,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Update a selected live Item in a Collection. The updates for this Item will be published to the live site. </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        id : str
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow import CollectionItemFieldData
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.update_item_live(
            collection_id="collection_id",
            item_id="item_id",
            id="42b720ef280c7a7a3be8cabe",
            cms_locale_id="653ad57de882f528b32e810e",
            last_published="2022-11-29T16:22:43.159Z",
            last_updated="2022-11-17T17:19:43.282Z",
            created_on="2022-11-17T17:11:57.148Z",
            is_archived=False,
            is_draft=False,
            field_data=CollectionItemFieldData(
                name="Pan Galactic Gargle Blaster Recipe",
                slug="pan-galactic-gargle-blaster",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="PATCH",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": field_data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItem, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def publish_item(
        self,
        collection_id: str,
        *,
        item_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Publish an item or multiple items. </br></br> Required scope | `cms:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.publish_item(
            collection_id="collection_id",
            item_ids=["itemIds"],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/publish",
            method="POST",
            json={"itemIds": item_ids},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncItemsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_items(
        self,
        collection_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        name: typing.Optional[str] = None,
        slug: typing.Optional[str] = None,
        sort_by: typing.Optional[ItemsListItemsRequestSortBy] = None,
        sort_order: typing.Optional[ItemsListItemsRequestSortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItemList:
        """
        List of all Items within a Collection. </br></br> Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        name : typing.Optional[str]
            The name of the item(s)

        slug : typing.Optional[str]
            The slug of the item

        sort_by : typing.Optional[ItemsListItemsRequestSortBy]
            Sort results by the provided value

        sort_order : typing.Optional[ItemsListItemsRequestSortOrder]
            Sorts the results by asc or desc

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItemList
            Request was successful

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.list_items(
            collection_id="collection_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
                "offset": offset,
                "limit": limit,
                "name": name,
                "slug": slug,
                "sortBy": sort_by,
                "sortOrder": sort_order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItemList, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_item(
        self,
        collection_id: str,
        *,
        id: str,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Create Item in a Collection.</br></br> To create items across multiple locales, <a href="https://developers.webflow.com/data/reference/create-item-for-multiple-locales"> please use this endpoint.</a> </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        id : str
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow import CollectionItemFieldData
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.create_item(
            collection_id="collection_id",
            id="42b720ef280c7a7a3be8cabe",
            cms_locale_id="653ad57de882f528b32e810e",
            last_published="2022-11-29T16:22:43.159Z",
            last_updated="2022-11-17T17:19:43.282Z",
            created_on="2022-11-17T17:11:57.148Z",
            is_archived=False,
            is_draft=False,
            field_data=CollectionItemFieldData(
                name="Pan Galactic Gargle Blaster Recipe",
                slug="pan-galactic-gargle-blaster",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="POST",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": field_data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_items_live(
        self,
        collection_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        name: typing.Optional[str] = None,
        slug: typing.Optional[str] = None,
        sort_by: typing.Optional[ItemsListItemsLiveRequestSortBy] = None,
        sort_order: typing.Optional[ItemsListItemsLiveRequestSortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItemList:
        """
        List of all live Items within a Collection. </br></br> Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        name : typing.Optional[str]
            The name of the item(s)

        slug : typing.Optional[str]
            The slug of the item

        sort_by : typing.Optional[ItemsListItemsLiveRequestSortBy]
            Sort results by the provided value

        sort_order : typing.Optional[ItemsListItemsLiveRequestSortOrder]
            Sorts the results by asc or desc

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItemList
            Request was successful

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.list_items_live(
            collection_id="collection_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
                "offset": offset,
                "limit": limit,
                "name": name,
                "slug": slug,
                "sortBy": sort_by,
                "sortOrder": sort_order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItemList, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_item_live(
        self,
        collection_id: str,
        *,
        id: str,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Create live Item in a Collection. This Item will be published to the live site. </br></br> To create items across multiple locales, <a href="https://developers.webflow.com/data/reference/create-item-for-multiple-locales"> please use this endpoint.</a> </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        id : str
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow import CollectionItemFieldData
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.create_item_live(
            collection_id="collection_id",
            id="42b720ef280c7a7a3be8cabe",
            cms_locale_id="653ad57de882f528b32e810e",
            last_published="2022-11-29T16:22:43.159Z",
            last_updated="2022-11-17T17:19:43.282Z",
            created_on="2022-11-17T17:11:57.148Z",
            is_archived=False,
            is_draft=False,
            field_data=CollectionItemFieldData(
                name="Pan Galactic Gargle Blaster Recipe",
                slug="pan-galactic-gargle-blaster",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="POST",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": field_data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_item_for_multiple_locales(
        self,
        collection_id: str,
        *,
        id: str,
        cms_locale_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[BulkCollectionItemFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Create single Item in a Collection with multiple corresponding locales. </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        id : str
            Unique identifier for the Item

        cms_locale_ids : typing.Optional[typing.Sequence[str]]
            Array of identifiers for the locales where the item will be created

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[BulkCollectionItemFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.create_item_for_multiple_locales(
            collection_id="collection_id",
            id="580e64008c9a982ac9b8b754",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/bulk",
            method="POST",
            json={
                "id": id,
                "cmsLocaleIds": cms_locale_ids,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": field_data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Get details of a selected Collection Item. </br></br> Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.get_item(
            collection_id="collection_id",
            item_id="item_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="GET",
            params={"cmsLocaleId": cms_locale_id},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItem, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete an Item from a Collection. This endpoint does not currently support bulk deletion. </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.delete_item(
            collection_id="collection_id",
            item_id="item_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="DELETE",
            params={"cmsLocaleId": cms_locale_id},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        id: str,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Update a selected Item in a Collection. </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        id : str
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow import CollectionItemFieldData
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.update_item(
            collection_id="collection_id",
            item_id="item_id",
            id="42b720ef280c7a7a3be8cabe",
            cms_locale_id="653ad57de882f528b32e810e",
            last_published="2022-11-29T16:22:43.159Z",
            last_updated="2022-11-17T17:19:43.282Z",
            created_on="2022-11-17T17:11:57.148Z",
            is_archived=False,
            is_draft=False,
            field_data=CollectionItemFieldData(
                name="Pan Galactic Gargle Blaster Recipe",
                slug="pan-galactic-gargle-blaster",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="PATCH",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": field_data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItem, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Get details of a selected Collection live Item. </br></br> Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.get_item_live(
            collection_id="collection_id",
            item_id="item_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="GET",
            params={"cmsLocaleId": cms_locale_id},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItem, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Remove a live item from the site. Removing a published item will unpublish the item from the live site and set it to draft. This endpoint does not currently support bulk deletion. </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.delete_item_live(
            collection_id="collection_id",
            item_id="item_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="DELETE",
            params={"cmsLocaleId": cms_locale_id},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        id: str,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Update a selected live Item in a Collection. The updates for this Item will be published to the live site. </br></br> Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        id : str
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow import CollectionItemFieldData
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.update_item_live(
            collection_id="collection_id",
            item_id="item_id",
            id="42b720ef280c7a7a3be8cabe",
            cms_locale_id="653ad57de882f528b32e810e",
            last_published="2022-11-29T16:22:43.159Z",
            last_updated="2022-11-17T17:19:43.282Z",
            created_on="2022-11-17T17:11:57.148Z",
            is_archived=False,
            is_draft=False,
            field_data=CollectionItemFieldData(
                name="Pan Galactic Gargle Blaster Recipe",
                slug="pan-galactic-gargle-blaster",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="PATCH",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": field_data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CollectionItem, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def publish_item(
        self,
        collection_id: str,
        *,
        item_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Publish an item or multiple items. </br></br> Required scope | `cms:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.collections.items.publish_item(
            collection_id="collection_id",
            item_ids=["itemIds"],
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/publish",
            method="POST",
            json={"itemIds": item_ids},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
