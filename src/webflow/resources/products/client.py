# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import pydantic_v1
from ...core.request_options import RequestOptions
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_found_error import NotFoundError
from ...errors.too_many_requests_error import TooManyRequestsError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.product import Product
from ...types.product_and_sk_us import ProductAndSkUs
from ...types.product_and_sk_us_list import ProductAndSkUsList
from ...types.publish_status import PublishStatus
from ...types.sku import Sku
from .types.products_create_sku_response import ProductsCreateSkuResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ProductsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        site_id: str,
        *,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUsList:
        """
        Retrieve all products for a site. Use `limit` and `offset` to page through all products with subsequent requests. All SKUs for each product will also be fetched and returned. The `limit`, `offset` and `total` values represent Products only and do not include any SKUs.

        Required scope | `ecommerce:read`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUsList
            Request was successful

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.list(
            site_id="site_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products",
            method="GET",
            params={"offset": offset, "limit": limit},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ProductAndSkUsList, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        site_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: typing.Optional[Product] = OMIT,
        sku: typing.Optional[Sku] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUs:
        """
        Creating a new Product involves creating both a Product and a SKU, since a Product Item has to have, at minimum, a single SKU.

        In order to create a Product with multiple SKUs - for example a T-shirt in sizes small, medium and large - you'll need to create `sku-properties`. In our T-shirt example, a single `sku-property` would be Color. Within that property, we'll need to list out the various colors a T-shirt could be as an array of `enum` values: `royal-blue`, `crimson-red`, and `forrest-green`.

        Once, you've created a Product and its `sku-properties` with `enum` values, you can create your default SKU, which will automatically be a combination of the first `sku-properties` you've created. In our example, the default SKU will be a Royal Blue T-Shirt, because our first `enum` of our Color `sku-property` is Royal Blue. After you've created your product, you can create additional SKUs using the <a href="https://developers.webflow.com/reference/create-skus">Create SKU endpoint</a>

        Upon creation, the default product type will be `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        publish_status : typing.Optional[PublishStatus]

        product : typing.Optional[Product]

        sku : typing.Optional[Sku]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUs
            Request was successful

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.create(
            site_id="site_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products",
            method="POST",
            json={"publishStatus": publish_status, "product": product, "sku": sku},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, site_id: str, product_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProductAndSkUs:
        """
        Retrieve a single product by its id. All of its SKUs will also be retrieved.

        Required scope | `ecommerce:read`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUs
            Request was successful

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.get(
            site_id="site_id",
            product_id="product_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        site_id: str,
        product_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: typing.Optional[Product] = OMIT,
        sku: typing.Optional[Sku] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Product:
        """
        Updating an existing Product will set the product type to `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        publish_status : typing.Optional[PublishStatus]

        product : typing.Optional[Product]

        sku : typing.Optional[Sku]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Product
            Request was successful

        Examples
        --------
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.update(
            site_id="site_id",
            product_id="product_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            method="PATCH",
            json={"publishStatus": publish_status, "product": product, "sku": sku},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(Product, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_sku(
        self,
        site_id: str,
        product_id: str,
        *,
        skus: typing.Sequence[Sku],
        publish_status: typing.Optional[PublishStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductsCreateSkuResponse:
        """
        Create additional SKUs to cover every variant of your Product. The Default SKU already counts as one of the variants.

        Creating additional SKUs will set the product type to `Advanced` for the product associated with the SKUs. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        skus : typing.Sequence[Sku]
            An array of the SKU data your are adding

        publish_status : typing.Optional[PublishStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductsCreateSkuResponse
            Request was successful

        Examples
        --------
        from webflow import Sku
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.create_sku(
            site_id="site_id",
            product_id="product_id",
            skus=[Sku()],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus",
            method="POST",
            json={"publishStatus": publish_status, "skus": skus},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ProductsCreateSkuResponse, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_sku(
        self,
        site_id: str,
        product_id: str,
        sku_id: str,
        *,
        sku: Sku,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sku:
        """
        Updating an existing SKU will set the product type to `Advanced` for the product associated with the SKU. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        sku_id : str
            Unique identifier for a SKU

        sku : Sku

        publish_status : typing.Optional[PublishStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sku
            Request was successful

        Examples
        --------
        from webflow import Sku
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.update_sku(
            site_id="site_id",
            product_id="product_id",
            sku_id="sku_id",
            sku=Sku(),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus/{jsonable_encoder(sku_id)}",
            method="PATCH",
            json={"publishStatus": publish_status, "sku": sku},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(Sku, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncProductsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        site_id: str,
        *,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUsList:
        """
        Retrieve all products for a site. Use `limit` and `offset` to page through all products with subsequent requests. All SKUs for each product will also be fetched and returned. The `limit`, `offset` and `total` values represent Products only and do not include any SKUs.

        Required scope | `ecommerce:read`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUsList
            Request was successful

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.list(
            site_id="site_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products",
            method="GET",
            params={"offset": offset, "limit": limit},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ProductAndSkUsList, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        site_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: typing.Optional[Product] = OMIT,
        sku: typing.Optional[Sku] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUs:
        """
        Creating a new Product involves creating both a Product and a SKU, since a Product Item has to have, at minimum, a single SKU.

        In order to create a Product with multiple SKUs - for example a T-shirt in sizes small, medium and large - you'll need to create `sku-properties`. In our T-shirt example, a single `sku-property` would be Color. Within that property, we'll need to list out the various colors a T-shirt could be as an array of `enum` values: `royal-blue`, `crimson-red`, and `forrest-green`.

        Once, you've created a Product and its `sku-properties` with `enum` values, you can create your default SKU, which will automatically be a combination of the first `sku-properties` you've created. In our example, the default SKU will be a Royal Blue T-Shirt, because our first `enum` of our Color `sku-property` is Royal Blue. After you've created your product, you can create additional SKUs using the <a href="https://developers.webflow.com/reference/create-skus">Create SKU endpoint</a>

        Upon creation, the default product type will be `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        publish_status : typing.Optional[PublishStatus]

        product : typing.Optional[Product]

        sku : typing.Optional[Sku]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUs
            Request was successful

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.create(
            site_id="site_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products",
            method="POST",
            json={"publishStatus": publish_status, "product": product, "sku": sku},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, site_id: str, product_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProductAndSkUs:
        """
        Retrieve a single product by its id. All of its SKUs will also be retrieved.

        Required scope | `ecommerce:read`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUs
            Request was successful

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.get(
            site_id="site_id",
            product_id="product_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        site_id: str,
        product_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: typing.Optional[Product] = OMIT,
        sku: typing.Optional[Sku] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Product:
        """
        Updating an existing Product will set the product type to `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        publish_status : typing.Optional[PublishStatus]

        product : typing.Optional[Product]

        sku : typing.Optional[Sku]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Product
            Request was successful

        Examples
        --------
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.update(
            site_id="site_id",
            product_id="product_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            method="PATCH",
            json={"publishStatus": publish_status, "product": product, "sku": sku},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(Product, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_sku(
        self,
        site_id: str,
        product_id: str,
        *,
        skus: typing.Sequence[Sku],
        publish_status: typing.Optional[PublishStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductsCreateSkuResponse:
        """
        Create additional SKUs to cover every variant of your Product. The Default SKU already counts as one of the variants.

        Creating additional SKUs will set the product type to `Advanced` for the product associated with the SKUs. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        skus : typing.Sequence[Sku]
            An array of the SKU data your are adding

        publish_status : typing.Optional[PublishStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductsCreateSkuResponse
            Request was successful

        Examples
        --------
        from webflow import Sku
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.create_sku(
            site_id="site_id",
            product_id="product_id",
            skus=[Sku()],
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus",
            method="POST",
            json={"publishStatus": publish_status, "skus": skus},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ProductsCreateSkuResponse, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_sku(
        self,
        site_id: str,
        product_id: str,
        sku_id: str,
        *,
        sku: Sku,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sku:
        """
        Updating an existing SKU will set the product type to `Advanced` for the product associated with the SKU. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        sku_id : str
            Unique identifier for a SKU

        sku : Sku

        publish_status : typing.Optional[PublishStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sku
            Request was successful

        Examples
        --------
        from webflow import Sku
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.update_sku(
            site_id="site_id",
            product_id="product_id",
            sku_id="sku_id",
            sku=Sku(),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus/{jsonable_encoder(sku_id)}",
            method="PATCH",
            json={"publishStatus": publish_status, "sku": sku},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(Sku, _response.json())  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 401:
                raise UnauthorizedError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 409:
                raise ConflictError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic_v1.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
