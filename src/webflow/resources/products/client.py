# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_found_error import NotFoundError
from ...errors.too_many_requests_error import TooManyRequestsError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.product import Product
from ...types.product_and_sk_us import ProductAndSkUs
from ...types.product_and_sk_us_list import ProductAndSkUsList
from ...types.publish_status import PublishStatus
from ...types.sku import Sku
from .types.products_create_sku_response import ProductsCreateSkuResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ProductsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self, site_id: str, *, offset: typing.Optional[float] = None, limit: typing.Optional[float] = None
    ) -> ProductAndSkUsList:
        """
        Retrieve all products for a site. Use `limit` and `offset` to page through all products with subsequent requests. All SKUs for each product will also be fetched and returned. The `limit`, `offset` and `total` values represent Products only and do not include any SKUs.

        Required scope | `ecommerce:read`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - offset: typing.Optional[float]. Offset used for pagination if the results have more than limit records

            - limit: typing.Optional[float]. Maximum number of records to be returned (max limit: 100)
        ---
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.list(
            site_id="site-id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products"),
            params=remove_none_from_dict({"offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUsList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self, site_id: str, *, publish_status: typing.Optional[PublishStatus] = OMIT, product: Product, sku: Sku
    ) -> ProductAndSkUs:
        """
        Adding a new Product involves creating both a Product Item and a SKU Item, since a Product Item has to have, at minimum, a SKU Item.

        To create a new Product with multiple SKUs, you must:

        - Create the Product and Default SKU using this endpoint, making sure to add `sku-properties` in the product data.
        - You can't add `sku-values` to the SKU yet, since there are no enum IDs created yet. When this endpoint returns, it will have IDs filled in for the `sku-properties` enums.
        - With those IDs, update the default SKU with valid `sku-values` and create any additional SKUs (if needed), with valid `sku-values`.
        - You can also create the Product without `sku-properties` and add them in later.
        - If you add any `sku` properties, the default SKU will default to the first value of each option.

        Upon creation, the default product type will be `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - publish_status: typing.Optional[PublishStatus].

            - product: Product.

            - sku: Sku.
        ---
        import datetime

        from webflow import (
            Product,
            ProductFieldData,
            PublishStatus,
            Sku,
            SkuFieldData,
            SkuFieldDataPrice,
            SkuPropertyList,
            SkuPropertyListEnumItem,
        )
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.create(
            site_id="site-id",
            publish_status=PublishStatus.STAGING,
            product=Product(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                is_archived=False,
                is_draft=False,
                field_data=ProductFieldData(
                    name="My new item",
                    slug="my-new-item",
                    sku_properties=[
                        SkuPropertyList(
                            id="ff42fee0113744f693a764e3431a9cc2",
                            name="Color",
                            enum=[
                                SkuPropertyListEnumItem(
                                    id="64a74715c456e36762fc39a1",
                                    name="Royal Blue",
                                    slug="royal-blue",
                                )
                            ],
                        )
                    ],
                ),
            ),
            sku=Sku(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                field_data=SkuFieldData(
                    name="My new item",
                    slug="my-new-item",
                    price=SkuFieldDataPrice(
                        value=100.0,
                        unit="USD",
                    ),
                ),
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"product": product, "sku": sku}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, site_id: str, product_id: str) -> ProductAndSkUs:
        """
        Retrieve a single product by its id. All of its SKUs will also be retrieved.

        Required scope | `ecommerce:read`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product
        ---
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.get(
            site_id="site-id",
            product_id="product-id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products/{product_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self, site_id: str, product_id: str, *, publish_status: typing.Optional[PublishStatus] = OMIT, product: Product
    ) -> Product:
        """
        Updating an existing Product will set the product type to `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - publish_status: typing.Optional[PublishStatus].

            - product: Product.
        ---
        import datetime

        from webflow import (
            Product,
            ProductFieldData,
            PublishStatus,
            SkuPropertyList,
            SkuPropertyListEnumItem,
        )
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.update(
            site_id="site-id",
            product_id="product-id",
            publish_status=PublishStatus.STAGING,
            product=Product(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                is_archived=False,
                is_draft=False,
                field_data=ProductFieldData(
                    name="My new item",
                    slug="my-new-item",
                    sku_properties=[
                        SkuPropertyList(
                            id="ff42fee0113744f693a764e3431a9cc2",
                            name="Color",
                            enum=[
                                SkuPropertyListEnumItem(
                                    id="64a74715c456e36762fc39a1",
                                    name="Royal Blue",
                                    slug="royal-blue",
                                )
                            ],
                        )
                    ],
                ),
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"product": product}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products/{product_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Product, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_sku(
        self,
        site_id: str,
        product_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        skus: typing.List[Sku],
    ) -> ProductsCreateSkuResponse:
        """
        Create additional SKUs to cover every variant of your Product. The Default SKU already counts as one of the variants.

        Creating additional SKUs will set the product type to `Advanced` for the product associated with the SKUs. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - publish_status: typing.Optional[PublishStatus].

            - skus: typing.List[Sku]. An array of the SKU data your are adding
        ---
        import datetime

        from webflow import PublishStatus, Sku, SkuFieldData, SkuFieldDataPrice
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.create_sku(
            site_id="site-id",
            product_id="product-id",
            publish_status=PublishStatus.STAGING,
            skus=[
                Sku(
                    id="580e63fc8c9a982ac9b8b745",
                    last_published=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35.560000+00:00",
                    ),
                    last_updated=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35.560000+00:00",
                    ),
                    created_on=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35.560000+00:00",
                    ),
                    field_data=SkuFieldData(
                        name="My new item",
                        slug="my-new-item",
                        price=SkuFieldDataPrice(
                            value=100.0,
                            unit="USD",
                        ),
                    ),
                )
            ],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"skus": skus}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products/{product_id}/skus"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductsCreateSkuResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_sku(
        self,
        site_id: str,
        product_id: str,
        sku_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        sku: Sku,
    ) -> Sku:
        """
        Updating an existing SKU will set the product type to `Advanced` for the product associated with the SKU. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - sku_id: str. Unique identifier for a SKU

            - publish_status: typing.Optional[PublishStatus].

            - sku: Sku.
        ---
        import datetime

        from webflow import PublishStatus, Sku, SkuFieldData, SkuFieldDataPrice
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.update_sku(
            site_id="site-id",
            product_id="product-id",
            sku_id="sku-id",
            publish_status=PublishStatus.STAGING,
            sku=Sku(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                field_data=SkuFieldData(
                    name="My new item",
                    slug="my-new-item",
                    price=SkuFieldDataPrice(
                        value=100.0,
                        unit="USD",
                    ),
                ),
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"sku": sku}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products/{product_id}/skus/{sku_id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Sku, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncProductsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self, site_id: str, *, offset: typing.Optional[float] = None, limit: typing.Optional[float] = None
    ) -> ProductAndSkUsList:
        """
        Retrieve all products for a site. Use `limit` and `offset` to page through all products with subsequent requests. All SKUs for each product will also be fetched and returned. The `limit`, `offset` and `total` values represent Products only and do not include any SKUs.

        Required scope | `ecommerce:read`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - offset: typing.Optional[float]. Offset used for pagination if the results have more than limit records

            - limit: typing.Optional[float]. Maximum number of records to be returned (max limit: 100)
        ---
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.list(
            site_id="site-id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products"),
            params=remove_none_from_dict({"offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUsList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self, site_id: str, *, publish_status: typing.Optional[PublishStatus] = OMIT, product: Product, sku: Sku
    ) -> ProductAndSkUs:
        """
        Adding a new Product involves creating both a Product Item and a SKU Item, since a Product Item has to have, at minimum, a SKU Item.

        To create a new Product with multiple SKUs, you must:

        - Create the Product and Default SKU using this endpoint, making sure to add `sku-properties` in the product data.
        - You can't add `sku-values` to the SKU yet, since there are no enum IDs created yet. When this endpoint returns, it will have IDs filled in for the `sku-properties` enums.
        - With those IDs, update the default SKU with valid `sku-values` and create any additional SKUs (if needed), with valid `sku-values`.
        - You can also create the Product without `sku-properties` and add them in later.
        - If you add any `sku` properties, the default SKU will default to the first value of each option.

        Upon creation, the default product type will be `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - publish_status: typing.Optional[PublishStatus].

            - product: Product.

            - sku: Sku.
        ---
        import datetime

        from webflow import (
            Product,
            ProductFieldData,
            PublishStatus,
            Sku,
            SkuFieldData,
            SkuFieldDataPrice,
            SkuPropertyList,
            SkuPropertyListEnumItem,
        )
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.create(
            site_id="site-id",
            publish_status=PublishStatus.STAGING,
            product=Product(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                is_archived=False,
                is_draft=False,
                field_data=ProductFieldData(
                    name="My new item",
                    slug="my-new-item",
                    sku_properties=[
                        SkuPropertyList(
                            id="ff42fee0113744f693a764e3431a9cc2",
                            name="Color",
                            enum=[
                                SkuPropertyListEnumItem(
                                    id="64a74715c456e36762fc39a1",
                                    name="Royal Blue",
                                    slug="royal-blue",
                                )
                            ],
                        )
                    ],
                ),
            ),
            sku=Sku(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                field_data=SkuFieldData(
                    name="My new item",
                    slug="my-new-item",
                    price=SkuFieldDataPrice(
                        value=100.0,
                        unit="USD",
                    ),
                ),
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"product": product, "sku": sku}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, site_id: str, product_id: str) -> ProductAndSkUs:
        """
        Retrieve a single product by its id. All of its SKUs will also be retrieved.

        Required scope | `ecommerce:read`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product
        ---
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.get(
            site_id="site-id",
            product_id="product-id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products/{product_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self, site_id: str, product_id: str, *, publish_status: typing.Optional[PublishStatus] = OMIT, product: Product
    ) -> Product:
        """
        Updating an existing Product will set the product type to `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - publish_status: typing.Optional[PublishStatus].

            - product: Product.
        ---
        import datetime

        from webflow import (
            Product,
            ProductFieldData,
            PublishStatus,
            SkuPropertyList,
            SkuPropertyListEnumItem,
        )
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.update(
            site_id="site-id",
            product_id="product-id",
            publish_status=PublishStatus.STAGING,
            product=Product(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                is_archived=False,
                is_draft=False,
                field_data=ProductFieldData(
                    name="My new item",
                    slug="my-new-item",
                    sku_properties=[
                        SkuPropertyList(
                            id="ff42fee0113744f693a764e3431a9cc2",
                            name="Color",
                            enum=[
                                SkuPropertyListEnumItem(
                                    id="64a74715c456e36762fc39a1",
                                    name="Royal Blue",
                                    slug="royal-blue",
                                )
                            ],
                        )
                    ],
                ),
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"product": product}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products/{product_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Product, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_sku(
        self,
        site_id: str,
        product_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        skus: typing.List[Sku],
    ) -> ProductsCreateSkuResponse:
        """
        Create additional SKUs to cover every variant of your Product. The Default SKU already counts as one of the variants.

        Creating additional SKUs will set the product type to `Advanced` for the product associated with the SKUs. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - publish_status: typing.Optional[PublishStatus].

            - skus: typing.List[Sku]. An array of the SKU data your are adding
        ---
        import datetime

        from webflow import PublishStatus, Sku, SkuFieldData, SkuFieldDataPrice
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.create_sku(
            site_id="site-id",
            product_id="product-id",
            publish_status=PublishStatus.STAGING,
            skus=[
                Sku(
                    id="580e63fc8c9a982ac9b8b745",
                    last_published=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35.560000+00:00",
                    ),
                    last_updated=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35.560000+00:00",
                    ),
                    created_on=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35.560000+00:00",
                    ),
                    field_data=SkuFieldData(
                        name="My new item",
                        slug="my-new-item",
                        price=SkuFieldDataPrice(
                            value=100.0,
                            unit="USD",
                        ),
                    ),
                )
            ],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"skus": skus}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products/{product_id}/skus"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductsCreateSkuResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_sku(
        self,
        site_id: str,
        product_id: str,
        sku_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        sku: Sku,
    ) -> Sku:
        """
        Updating an existing SKU will set the product type to `Advanced` for the product associated with the SKU. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - sku_id: str. Unique identifier for a SKU

            - publish_status: typing.Optional[PublishStatus].

            - sku: Sku.
        ---
        import datetime

        from webflow import PublishStatus, Sku, SkuFieldData, SkuFieldDataPrice
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.update_sku(
            site_id="site-id",
            product_id="product-id",
            sku_id="sku-id",
            publish_status=PublishStatus.STAGING,
            sku=Sku(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35.560000+00:00",
                ),
                field_data=SkuFieldData(
                    name="My new item",
                    slug="my-new-item",
                    price=SkuFieldDataPrice(
                        value=100.0,
                        unit="USD",
                    ),
                ),
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"sku": sku}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sites/{site_id}/products/{product_id}/skus/{sku_id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Sku, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
