# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...core.request_options import RequestOptions
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_found_error import NotFoundError
from ...errors.too_many_requests_error import TooManyRequestsError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.product import Product
from ...types.product_and_sk_us import ProductAndSkUs
from ...types.product_and_sk_us_list import ProductAndSkUsList
from ...types.publish_status import PublishStatus
from ...types.sku import Sku
from .types.product_sku_create_product import ProductSkuCreateProduct
from .types.product_sku_create_sku import ProductSkuCreateSku
from .types.products_create_sku_response import ProductsCreateSkuResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ProductsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        site_id: str,
        *,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUsList:
        """
        Retrieve all products for a site. Use `limit` and `offset` to page through all products with subsequent requests. All SKUs for each product will also be fetched and returned. The `limit`, `offset` and `total` values represent Products only and do not include any SKUs.

        Required scope | `ecommerce:read`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - offset: typing.Optional[float]. Offset used for pagination if the results have more than limit records

            - limit: typing.Optional[float]. Maximum number of records to be returned (max limit: 100)

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.list(
            site_id="site_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sites/{jsonable_encoder(site_id)}/products"
            ),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "offset": offset,
                        "limit": limit,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUsList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        site_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: typing.Optional[ProductSkuCreateProduct] = OMIT,
        sku: typing.Optional[ProductSkuCreateSku] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUs:
        """
        Creating a new Product involves creating both a Product and a SKU, since a Product Item has to have, at minimum, a single SKU.

        In order to create a Product with multiple SKUs - for example a T-shirt in sizes small, medium and large - you'll need to create `sku-properties`. In our T-shirt example, a single `sku-property` would be Color. Within that property, we'll need to list out the various colors a T-shirt could be as an array of `enum` values: `royal-blue`, `crimson-red`, and `forrest-green`.

        Once, you've created a Product and its `sku-properties` with `enum` values, you can create your default SKU, which will automatically be a combination of the first `sku-properties` you've created. In our example, the default SKU will be a Royal Blue T-Shirt, because our first `enum` of our Color `sku-property` is Royal Blue. After you've created your product, you can create additional SKUs using the <a href="https://developers.webflow.com/reference/create-skus">Create SKU endpoint</a>

        Upon creation, the default product type will be `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - publish_status: typing.Optional[PublishStatus].

            - product: typing.Optional[ProductSkuCreateProduct]. The Product Object

            - sku: typing.Optional[ProductSkuCreateSku]. The SKU object

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.create(
            site_id="site_id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status.value if publish_status is not None else None
        if product is not OMIT:
            _request["product"] = product
        if sku is not OMIT:
            _request["sku"] = sku
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sites/{jsonable_encoder(site_id)}/products"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, site_id: str, product_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProductAndSkUs:
        """
        Retrieve a single product by its id. All of its SKUs will also be retrieved.

        Required scope | `ecommerce:read`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.get(
            site_id="site_id",
            product_id="product_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        site_id: str,
        product_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: Product,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Product:
        """
        Updating an existing Product will set the product type to `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - publish_status: typing.Optional[PublishStatus].

            - product: Product.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        import datetime

        from webflow import (
            Product,
            ProductFieldData,
            SkuPropertyList,
            SkuPropertyListEnumItem,
        )
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.update(
            site_id="site_id",
            product_id="product_id",
            product=Product(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                is_archived=False,
                is_draft=False,
                field_data=ProductFieldData(
                    name="T-Shirt",
                    slug="t-shirt",
                    description="A plain cotton t-shirt.",
                    shippable=True,
                    sku_properties=[
                        SkuPropertyList(
                            id="color",
                            name="Color",
                            enum=[
                                SkuPropertyListEnumItem(
                                    id="royal-blue",
                                    name="Royal Blue",
                                    slug="royal-blue",
                                ),
                                SkuPropertyListEnumItem(
                                    id="crimson-red",
                                    name="Crimson Red",
                                    slug="crimson-red",
                                ),
                                SkuPropertyListEnumItem(
                                    id="forrest-green",
                                    name="Forrst Green",
                                    slug="forrest-green",
                                ),
                                SkuPropertyListEnumItem(
                                    id="id",
                                    name="name",
                                    slug="slug",
                                ),
                            ],
                        ),
                        SkuPropertyList(
                            id="Color",
                            name="Color",
                            enum=[
                                SkuPropertyListEnumItem(
                                    id="id",
                                    name="name",
                                    slug="slug",
                                )
                            ],
                        ),
                    ],
                ),
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"product": product}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status.value if publish_status is not None else None
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Product, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_sku(
        self,
        site_id: str,
        product_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        skus: typing.Sequence[Sku],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductsCreateSkuResponse:
        """
        Create additional SKUs to cover every variant of your Product. The Default SKU already counts as one of the variants.

        Creating additional SKUs will set the product type to `Advanced` for the product associated with the SKUs. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - publish_status: typing.Optional[PublishStatus].

            - skus: typing.Sequence[Sku]. An array of the SKU data your are adding

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        import datetime

        from webflow import Sku, SkuFieldData, SkuFieldDataPrice
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.create_sku(
            site_id="site_id",
            product_id="product_id",
            skus=[
                Sku(
                    id="580e63fc8c9a982ac9b8b745",
                    last_published=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35+00:00",
                    ),
                    last_updated=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35+00:00",
                    ),
                    created_on=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35+00:00",
                    ),
                    field_data=SkuFieldData(
                        name="Blue T-shirt",
                        slug="t-shirt-blue",
                        price=SkuFieldDataPrice(
                            value=100.0,
                            unit="USD",
                        ),
                        quantity=10.0,
                    ),
                )
            ],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"skus": skus}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status.value if publish_status is not None else None
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductsCreateSkuResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_sku(
        self,
        site_id: str,
        product_id: str,
        sku_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        sku: Sku,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sku:
        """
        Updating an existing SKU will set the product type to `Advanced` for the product associated with the SKU. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - sku_id: str. Unique identifier for a SKU

            - publish_status: typing.Optional[PublishStatus].

            - sku: Sku.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        import datetime

        from webflow import Sku, SkuFieldData, SkuFieldDataPrice
        from webflow.client import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.update_sku(
            site_id="site_id",
            product_id="product_id",
            sku_id="sku_id",
            sku=Sku(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                field_data=SkuFieldData(
                    name="Blue T-shirt",
                    slug="t-shirt-blue",
                    price=SkuFieldDataPrice(
                        value=100.0,
                        unit="USD",
                    ),
                    quantity=10.0,
                ),
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"sku": sku}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status.value if publish_status is not None else None
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus/{jsonable_encoder(sku_id)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Sku, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncProductsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        site_id: str,
        *,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUsList:
        """
        Retrieve all products for a site. Use `limit` and `offset` to page through all products with subsequent requests. All SKUs for each product will also be fetched and returned. The `limit`, `offset` and `total` values represent Products only and do not include any SKUs.

        Required scope | `ecommerce:read`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - offset: typing.Optional[float]. Offset used for pagination if the results have more than limit records

            - limit: typing.Optional[float]. Maximum number of records to be returned (max limit: 100)

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.list(
            site_id="site_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sites/{jsonable_encoder(site_id)}/products"
            ),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "offset": offset,
                        "limit": limit,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUsList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        site_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: typing.Optional[ProductSkuCreateProduct] = OMIT,
        sku: typing.Optional[ProductSkuCreateSku] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUs:
        """
        Creating a new Product involves creating both a Product and a SKU, since a Product Item has to have, at minimum, a single SKU.

        In order to create a Product with multiple SKUs - for example a T-shirt in sizes small, medium and large - you'll need to create `sku-properties`. In our T-shirt example, a single `sku-property` would be Color. Within that property, we'll need to list out the various colors a T-shirt could be as an array of `enum` values: `royal-blue`, `crimson-red`, and `forrest-green`.

        Once, you've created a Product and its `sku-properties` with `enum` values, you can create your default SKU, which will automatically be a combination of the first `sku-properties` you've created. In our example, the default SKU will be a Royal Blue T-Shirt, because our first `enum` of our Color `sku-property` is Royal Blue. After you've created your product, you can create additional SKUs using the <a href="https://developers.webflow.com/reference/create-skus">Create SKU endpoint</a>

        Upon creation, the default product type will be `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - publish_status: typing.Optional[PublishStatus].

            - product: typing.Optional[ProductSkuCreateProduct]. The Product Object

            - sku: typing.Optional[ProductSkuCreateSku]. The SKU object

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.create(
            site_id="site_id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status.value if publish_status is not None else None
        if product is not OMIT:
            _request["product"] = product
        if sku is not OMIT:
            _request["sku"] = sku
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sites/{jsonable_encoder(site_id)}/products"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, site_id: str, product_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProductAndSkUs:
        """
        Retrieve a single product by its id. All of its SKUs will also be retrieved.

        Required scope | `ecommerce:read`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.get(
            site_id="site_id",
            product_id="product_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductAndSkUs, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        site_id: str,
        product_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: Product,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Product:
        """
        Updating an existing Product will set the product type to `Advanced`. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - publish_status: typing.Optional[PublishStatus].

            - product: Product.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        import datetime

        from webflow import (
            Product,
            ProductFieldData,
            SkuPropertyList,
            SkuPropertyListEnumItem,
        )
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.update(
            site_id="site_id",
            product_id="product_id",
            product=Product(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                is_archived=False,
                is_draft=False,
                field_data=ProductFieldData(
                    name="T-Shirt",
                    slug="t-shirt",
                    description="A plain cotton t-shirt.",
                    shippable=True,
                    sku_properties=[
                        SkuPropertyList(
                            id="color",
                            name="Color",
                            enum=[
                                SkuPropertyListEnumItem(
                                    id="royal-blue",
                                    name="Royal Blue",
                                    slug="royal-blue",
                                ),
                                SkuPropertyListEnumItem(
                                    id="crimson-red",
                                    name="Crimson Red",
                                    slug="crimson-red",
                                ),
                                SkuPropertyListEnumItem(
                                    id="forrest-green",
                                    name="Forrst Green",
                                    slug="forrest-green",
                                ),
                                SkuPropertyListEnumItem(
                                    id="id",
                                    name="name",
                                    slug="slug",
                                ),
                            ],
                        ),
                        SkuPropertyList(
                            id="Color",
                            name="Color",
                            enum=[
                                SkuPropertyListEnumItem(
                                    id="id",
                                    name="name",
                                    slug="slug",
                                )
                            ],
                        ),
                    ],
                ),
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"product": product}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status.value if publish_status is not None else None
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Product, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_sku(
        self,
        site_id: str,
        product_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        skus: typing.Sequence[Sku],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductsCreateSkuResponse:
        """
        Create additional SKUs to cover every variant of your Product. The Default SKU already counts as one of the variants.

        Creating additional SKUs will set the product type to `Advanced` for the product associated with the SKUs. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - publish_status: typing.Optional[PublishStatus].

            - skus: typing.Sequence[Sku]. An array of the SKU data your are adding

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        import datetime

        from webflow import Sku, SkuFieldData, SkuFieldDataPrice
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.create_sku(
            site_id="site_id",
            product_id="product_id",
            skus=[
                Sku(
                    id="580e63fc8c9a982ac9b8b745",
                    last_published=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35+00:00",
                    ),
                    last_updated=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35+00:00",
                    ),
                    created_on=datetime.datetime.fromisoformat(
                        "2023-03-17 18:47:35+00:00",
                    ),
                    field_data=SkuFieldData(
                        name="Blue T-shirt",
                        slug="t-shirt-blue",
                        price=SkuFieldDataPrice(
                            value=100.0,
                            unit="USD",
                        ),
                        quantity=10.0,
                    ),
                )
            ],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"skus": skus}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status.value if publish_status is not None else None
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProductsCreateSkuResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_sku(
        self,
        site_id: str,
        product_id: str,
        sku_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        sku: Sku,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sku:
        """
        Updating an existing SKU will set the product type to `Advanced` for the product associated with the SKU. The product type is used to determine which Product and SKU fields are shown to users in the `Designer` and the `Editor`. Setting it to `Advanced` ensures that all Product and SKU fields will be shown. The product type can be edited in the `Designer` or the `Editor`.

        Required scope | `ecommerce:write`

        Parameters:
            - site_id: str. Unique identifier for a Site

            - product_id: str. Unique identifier for a Product

            - sku_id: str. Unique identifier for a SKU

            - publish_status: typing.Optional[PublishStatus].

            - sku: Sku.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        import datetime

        from webflow import Sku, SkuFieldData, SkuFieldDataPrice
        from webflow.client import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        await client.products.update_sku(
            site_id="site_id",
            product_id="product_id",
            sku_id="sku_id",
            sku=Sku(
                id="580e63fc8c9a982ac9b8b745",
                last_published=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                created_on=datetime.datetime.fromisoformat(
                    "2023-03-17 18:47:35+00:00",
                ),
                field_data=SkuFieldData(
                    name="Blue T-shirt",
                    slug="t-shirt-blue",
                    price=SkuFieldDataPrice(
                        value=100.0,
                        unit="USD",
                    ),
                    quantity=10.0,
                ),
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"sku": sku}
        if publish_status is not OMIT:
            _request["publishStatus"] = publish_status.value if publish_status is not None else None
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus/{jsonable_encoder(sku_id)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Sku, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
